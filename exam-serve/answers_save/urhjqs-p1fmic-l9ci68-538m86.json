[{"title":"commonjs规范","questions_id":"ayf32j-5kv76-qvfqh-cigaoo","json_path":"ayf32j-5kv76-qvfqh-cigaoo.json","subject_text":"node基础","subject_id":"4pu32-vs796l","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"w916peach","user_id":"axg8t2-oroeja","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"请简述node环境下的commonjs规范（说出如何导出模块，如何引入模块，如何创建模块）？","student_answer":"node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即[module.exports]）是对外的接口。加载某个模块，其实是加载该模块的[module.exports]属性。require方法用于加载模块。\n\n.AMD规范和commonJS规范\n1.相同点：都是为了模块化。\n2.不同点：AMD规范则是非同步加载模块，允许指定回调函数。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。\n\n引入模块:\n\trequire(\"模块文件\")\n导出模块:\n\tmodule.exports = {\n    \t要导出的方法名: 当前模块的方法名\n    }\n\tmodule.exports = 当前模块需要导出的方法名\n创建模块:\n\t每一个js文件都是一个模块"},{"title":"let和var的区别","questions_id":"h7f6hq-cezl0g-fyu3o-6onwjf","json_path":"h7f6hq-cezl0g-fyu3o-6onwjf.json","subject_text":"node基础","subject_id":"4pu32-vs796l","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"w916peach","user_id":"axg8t2-oroeja","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"在声明变量的时候，使用`let`和`var`有什么区别呢？","student_answer":"区别1:\n\t[var]声明的变量具有变量提升的特点,浏览器在一加载页面的时候就会把带var关键字的提前声明但是不会赋值,在变量提升时var 的值是undefined ,只有当代码执行到对应行数的时候才会进行赋值。\n\t[let] 声明就没有变量提升的这个特点,它会有一个词法解析的一个特点,会在浏览器加载的时候提前把带let声明的都记录下来。\n区别2:\n\t[var] 声明的会和window建立映射关系,我们每一个通过var 声明的变量都可以使用window.XXX 获取到对应的值\n   [let] 声明的则和window切断了映射关系, 当我们使用window.XXX 获取就会得到 [undefined] 说明在window对象上没有这个属性\n区别3:\n\t[var] 声明的会有一个\"暂时性死区\",在未赋值之前我们使用这个变量获取的是[undefined] ,这样是不符合我们正常逻辑的。\n\t[let] 声明的变量就很好的解决了这个暂时性死区的问题,只要是通过let声明,因为没有变量提升,只有当代码执行到对应的行数才会进行声明赋值,在这之前只要使用了就会报错!\n区别4: \n\t[var] 声明的变量不会产生块级作用域\n   [let] 声明的变量就会产生块级作用域,每一个用大括号\"{ }\"包起来的都会形成一个块级作用域, 和大括号外边是没有关系的, 类似于函数执行形成的私有作用域,\n区别5:\n\t[var] 声明的变量在判断条件中也会被变量提升,当条件成立进入判断体中才会进行赋值。\n\t[let] 声明的变量在判断条件中会把当前所在判断体作为一个块级作用域,不受外界影响。\n\n"},{"title":"解构赋值和数组的map方法","questions_id":"izvfy-572mw-thxrmm-7aba5s","json_path":"izvfy-572mw-thxrmm-7aba5s.json","subject_text":"node基础","subject_id":"4pu32-vs796l","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"w916peach","user_id":"axg8t2-oroeja","questions_type_text":"代码阅读题","questions_type_id":"br9d6s-wh46i","questions_stem":"如下：是一段html结构\n```   \n    <ul>\n        <li key=\"1\"></li>\n        <li key=\"2\"></li>\n        <li key=\"3\"></li>\n        <li key=\"4\"></li>\n    </ul>\n```\n加载一段对应的javaScript代码\n\n```\n        let oUl = document.getElementsByTagName('ul')[0];\n        let li = document.getElementsByTagName('li');\n        const {map,forEach} = [];\n        li = map.call(li,item=>{\n            let key = 2 * item.getAttribute('key') - 1;\n            item.setAttribute('key',key);\n            return item;\n        });\n        oUl.innerHTML = '';\n        forEach.call(li,item=>{\n            oUl.appendChild(item);\n        })\n```\n\n请结合html和javaScript描述出这段代码的运行效果，并给每句代码添加注释，在注释中指明该句代码的含义","student_answer":"    <ul>\n        <li key=\"1\"></li>\n        <li key=\"2\"></li>\n        <li key=\"3\"></li>\n        <li key=\"4\"></li>\n    </ul>\n加载一段对应的javaScript代码\n \tlet oUl = document.getElementsByTagName('ul')[0]; //=> 获取到ul容器\n  \tlet li = document.getElementsByTagName('li'); //=> 获取到页面中所有的li\n   const {map,forEach} = []; //=> 获取到数组原型的map 和forEach 方法\n   li = map.call(li,item=>{  //=> 使用map方法通过改变map中的this 迭代我们的li\n\t\t\t\tlet key = 2 * item.getAttribute('key') - 1; //=>获取到每一个li的自定义属性的值乘2 再减1的结果保存起来,作为改变自定义属性的值\n         \titem.setAttribute('key',key); //=> 重新设置每一个li 自定义属性, 值是刚才保存计算的结果\n           return item; //=> 最后把改变后的li 返回出去\n        });\n   oUl.innerHTML = ''; //=> 清空ul中的内容\n   forEach.call(li,item=>{ //=> 迭代每一个li 把li 追加到ul中\n\t\toUl.appendChild(item);\n\t})\n这段代码运行的效果是 先改变ul中每一个li的自定义属性的值, 然后又清空了ul中的内容,然后又通过迭代把每个li追加到ul 中\n\n\n\n\n\n\n\n\n\n"},{"title":"解决以下异步代码问题","questions_id":"pwrym-ypsrgi-3smad-bm9d1m","json_path":"pwrym-ypsrgi-3smad-bm9d1m.json","subject_text":"node基础","subject_id":"4pu32-vs796l","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"检索并计算属于同一教室中每个学生的平均分数，例子中教室 ID 为 75。每个学生可以在一年内参加一门或多门课程。以下 API 可用于检索所需数据。\n```\n// GET LIST OF ALL STUDENTS\nGET /api/students\nResponse:\n[{\n    \"id\": 1,\n    \"name\": \"John\",\n    \"classroomId\": 75\n}]\n// GET COURSES FOR GIVEN A STUDENT\nGET /api/courses?filter=studentId eq 1\nResponse:\n[{\n    \"id\": \"history\",\n    \"studentId\": 1\n}, {\n    \"id\": \"algebra\",\n    \"studentId\": 1\n}]\n// GET EVALUATION FOR EACH COURSE\nGET /api/evaluation/history?filter=studentId eq 1\nResponse:\n{\n    \"id\": 200,\n    \"score\": 50,\n    \"totalScore\": 100\n}\n```\n编写一个接受教室 ID 的函数，并根据该函数计算该教室中每个学生的平均值。 该函数的最终输出应该是带有平均分数的学生列表：\n```\n[\n  { \"id\": 1, \"name\": \"John\", \"average\": 70.5 },\n  { \"id\": 3, \"name\": \"Lois\", \"average\": 67 },\n}\n```\n使用普通回调，promises，observables，generator 或 async-wait 编写所需的函数。 尝试使用至少 2 种不同的技术解决这个问题。\n代码素材用于代替接口\n```\nconst APIS = {\n  STUDENTS: '/api/students',\n  COURSES: '/api/courses',\n  EVALUATION: '/api/evaluation/'\n}; \nfunction fetchData(api) {\n  return new Promise(resolve => {\n    let data = null;\n    switch (api) {\n      case APIS.STUDENTS:\n        data = [{\n          id: 1,\n          name: 'John',\n          classroomId: 75\n        }, {\n          id: 1,\n          name: 'Tom',\n          classroomId: 75\n        }];\n        break;\n      case APIS.COURSES:\n        data = [{\n          id: 'history',\n          studentId: 1\n        }, {\n          id: 'algebra',\n          studentId: 1\n        }];\n        break;\n      case APIS.EVALUATION:\n        data = {\n          id: '200',\n          score: 50,\n          totalScore: 100\n        };\n        break;\n    } \n    resolve(data);\n  });\n} \n```","student_answer":"检索并计算属于同一教室中每个学生的平均分数，例子中教室 ID 为 75。每个学生可以在一年内参加一门或多门课程。以下 API 可用于检索所需数据。\n\nconst APIS = {\n  STUDENTS: '/api/students',\n  COURSES: '/api/courses',\n  EVALUATION: '/api/evaluation/'\n}; \nfunction fetchData(api) {\n  return new Promise(resolve => {\n    let data = null;\n    switch (api) {\n      case APIS.STUDENTS:\n        data = [{\n          id: 1,\n          name: 'John',\n          classroomId: 75\n        }, {\n          id: 1,\n          name: 'Tom',\n          classroomId: 75\n        }];\n        break;\n      case APIS.COURSES:\n        data = [{\n          id: 'history',\n          studentId: 1\n        }, {\n          id: 'algebra',\n          studentId: 1\n        }];\n        break;\n      case APIS.EVALUATION:\n        data = {\n          id: '200',\n          score: 50,\n          totalScore: 100\n        };\n        break;\n    } \n    resolve(data);\n  });\n} ;\n//编写一个接受教室 ID 的函数，并根据该函数计算该教室中每个学生的平均值。 该函数的最终输出应该是带有平均分数的学生列表：\nlet arr = []\nasync function average(a) {\n  let obj = {}\n  let students = await fetchData(\"/api/students\")\n  let courses = await fetchData(\"/api/courses\")\n  let evaluation = await fetchData(\"/api/evaluation/\")\n  students.map(item => {\n    if (item.classroomId == a) {\n      obj = {\n        id: item.id,\n        name: item.name\n      }\n    }\n    return arr.push(obj)\n  })\n}\nconsole.log(average(\"75\"))\n//使用普通回调，promises，observables，generator 或 async-wait 编写所需的函数。 尝试使用至少 2 种不同的技术解决这个问题。 代码素材用于代替接口\n\n\n\n\n\n\n\n\n"}]