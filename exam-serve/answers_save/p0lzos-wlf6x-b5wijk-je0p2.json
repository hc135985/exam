[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"computed在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存,而不必再次执行函数。而不必像 motheds方法 和 watch 方法每次都去执行函数。\ncomputed：是把所有需要依赖其他值计算的值写成对象的key值( 通过计算的变量不需要在data里面声明，如果声明了就会报错)。  watch：把监听的值写成对象的key值(需要监听的这个变量需要在data里面声明，如果不声明就会报错)\n不要在computed和watch中修改被依赖(或者被监听)的值，这样可能会导致无限循环\nwatch更加适用于监听某一个值的变化并做对应的操作，比如请求后台接口等，而computed适用于计算已有的值并返回结果\n白话说computed 多个值决定一个值  watch 一个值决定多个值"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"<div id=\"app\">\n        <input type=\"text\" id=\"txt\" v-model=\"show\">\n        <p id=\"show-txt\">{{show}}</p>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script>\n          new Vue({\n              el:\"#app\",\n              data:{\n                  show:\"\"\n              }\n          })\n          \n     </script>"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"\nconst whiteName=[\"detail\",\"myID\"]\nrouter.beforeEach((to, from, next) => {\n if(getToken()){//已经登录\n       if (to.name == \"login\") {  \n            next({\n              path: \"/\"//重定向到\"/\"\n            });\n       } else {\n          next();//直接跳转\n       }\n \n }else{//未登录\n       if(whiteName.includes(to.name)){\n       \t\tnext()\n       }else{\n           next({\n                path: \"/login\"//重定向到\"/login\"\n           });\n       }\n }\n \n});"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"数据定义:组件中定义数据{counter:0}；\n\t\t初始化过程中，会执行observe(data, this)；\n\t\t在observe（）过程中会将data这个对象劫持，通过Object.defineProperty将data上所有的属性绑定上getter\t\t\t和setter函数；（这是针对对象，对于数组，Vue通过改写数组的原生方法来劫持）；\n\t\t通俗的说就是只要谁获取了counter的值就会触发getter()；要是谁改变了counter的值就会触发setter();比如\t\t上述代码中的button绑定{{count}}的时候一定会触发getter();如果是count的值发生改变就一定会触发\t\t\tsetter()\n数据绑定:在页面元素button中绑定{{count}};\n      在编译过程中，针对这个button会产生一个Watcher(vm, exp, cb(newValue,oldValue)),vm是Vue对象，exp是\t\t  数据绑定的数据;cb（）的逻辑是用来更新页面。现在的问题是如何将数据的变化和Watcher关联起来。\n      在这里用到了一个重要的思想就是发布订阅模式；Watcher初始化的时候会将Dep.target设置为this,也就是       Watcher自己，同时会触发count的getter方法，getter里面会调用Dep的depend方法，depend方法会调用         Watcher的addDep方法，addDep方法就是将Watcher自己存放在Dep的事件池里面。\n数据响应:当发生点击事件的时候，count的值改变，会触发setter里面的方法，这个方法会调用dep.notify()；它会告\t\t知Dep的事件池里的存放的Watcher去执行它的update（）方法；Watcher的update()方法；这个方法里面会获取\t\tcount的新的值，给它的回调cb()，去更新视图"}]