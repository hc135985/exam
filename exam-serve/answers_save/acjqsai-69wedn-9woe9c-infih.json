[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"computed 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\nwatch 一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是 computed 和 methods 的结合体；"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<input type=\"text\" id=\"aa\"/>\n<span id=\"bb\">{{hello}}</span>\n<script>\n    var obj = {};\n    Object.defineProperty(obj,'hello',{\n        set:function(val){\n            document.getElementById('bb').innerHTML = val;\n            document.getElementById('aa').value = val;\n        }\n    });\n    document.getElementById('aa').onkeyup = function(e){\n        obj.hello = e.target.value;\n    };\n    obj.hello = \"\";\n\n\n</script>\n</body>\n</html>"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"<template>\n  <div>\n    <input type=\"text\" v-model=\"loginForm.username\" placeholder=\"用户名\"/>\n    <input type=\"text\" v-model=\"loginForm.password\" placeholder=\"密码\"/>\n    <button @click=\"login\">登录</button>\n  </div>\n</template>\n \n<script>\nimport { mapMutations } from 'vuex';\nexport default {\n  data () {\n    return {\n      loginForm: {\n        username: '',\n        password: ''\n      },\n      userToken: ''\n    };\n  },\n \n  methods: {\n    ...mapMutations(['changeLogin']),\n    login () {\n      let _this = this;\n      if (this.loginForm.username === '' || this.loginForm.password === '') {\n        alert('账号或密码不能为空');\n      } else {\n        this.axios({\n          method: 'post',\n          url: '/user/login',\n          data: _this.loginForm\n        }).then(res => {\n          console.log(res.data);\n          _this.userToken = 'Bearer ' + res.data.data.body.token;\n          // 将用户token保存到vuex中\n          _this.changeLogin({ Authorization: _this.userToken });\n          _this.$router.push('/home');\n          alert('登陆成功');\n        }).catch(error => {\n          alert('账号或密码错误');\n          console.log(error);\n        });\n      }\n    }\n  }\n};\n</script>\n"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"Watcher, Observer , Dep 的关系全都梳理完成。而这些也是 Vue 实现的核心逻辑之一。再来简单总结一下三者的关系，其实是一个简单的 观察-订阅 的设计模式, 简单来说就是， 观察者观察数据状态变化, 一旦数据发生变化，则会通知对应的订阅者，让订阅者执行对应的业务逻辑 。我们熟知的事件机制，就是一种典型的观察-订阅的模式\n\nObserver, 观察者，用来观察数据源变化. \nDep, 观察者和订阅者是典型的 一对多 的关系,所以这里设计了一个依赖中心,来管理某个观察者和所有这个观察者对应的订阅者的关系, 消息调度和依赖管理都靠它。 \nWatcher, 订阅者，当某个观察者观察到数据发生变化的时候，这个变化经过消息调度中心，最终会传递到所有该观察者对应的订阅者身上，然后这些订阅者分别执行自身的业务回调即可"}]