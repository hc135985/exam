[{"title":"性能优化","questions_id":"00a1t8-ezqkxg-xv9pkk-6hqfyb","json_path":"00a1t8-ezqkxg-xv9pkk-6hqfyb.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"请用js实现一个监听浏览器窗口变化的函数，当浏览器窗口的宽度大于等于 600px 的时候console.log('hello')（持续大于等于600px的话打印一次即可），请用你觉得最优的实现","student_answer":"let data=1;\nwindow.onresize = function() {\n    if(window.innerWidth>=600){\n        if(data){\n         \tconsole.log('hello')\n           data=0;\n         }\n    }else if(window.innerWidth<600){\n        data=1;\n    }\n}\n"},{"title":"多种组件创建方式及其区别？","questions_id":"cbssqf-16avt7-qwk8k-ufilrc","json_path":"cbssqf-16avt7-qwk8k-ufilrc.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 多种组件创建方式及其区别？","student_answer":"函数式定义的无状态组件\nfunction HelloComponent(props, /* context */) { //创建方式\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n\n无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：\n\n组件不会被实例化，整体渲染性能得到提升\n因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n组件不能访问this对象\n无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件\n组件无法访问生命周期的方法\n因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用\n无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件\n\nes5原生方式React.createClass定义的组件\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\nes6形式的extends React.Component定义的组件\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\nReact.createClass与React.Component区别\n函数this自绑定\n组件属性类型propTypes及其默认props属性defaultProps配置不同\n组件初始状态state的配置不同\nMixins的支持不同"},{"title":"封装图片加载Promise","questions_id":"gt8z4u-ufd66j-najaef-y8ytir","json_path":"gt8z4u-ufd66j-najaef-y8ytir.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 封装加载图片的promise  \n```js\nlet loadImg = (src)=>{\n    return new Promise((resolve, reject)=>{\n        // write your code here\n    })\n}\n```\n","student_answer":"let loadImg = (src)=>{\n  return new Promise((resolve, reject)=>{\n    const image = new Image();\n    image.onload = function() {\n      resolve(image);\n    };\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n    image.src = url;\n  });\n}"}]