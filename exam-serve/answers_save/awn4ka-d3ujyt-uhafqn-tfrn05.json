[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"computed\n计算属性：通过属性计算得来的属性\n计算属性,是在相关联的属性发生变化才计算，计算过一次，如果相关属性没有变化，下一次就不需要计算了，直接去缓存的值\nwatch\n属性变化，就会触发监听的函数。\n监听属性变化，一般是用于跟数据无关的业务逻辑操作。\n计算属性，适用于属性发生变化后，需要计算得到新的数据\n"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"第一种方法\nlet $i = document.querySelector('#txt');\nlet $p = document.querySelector('#show-txt');\nlet def = 'default';\n$i.value = def;\n$p.textContent = def;\n$i.oninput = function(){\n  $p.textContent = $i.value;\n}\n第二种方法\nvar obj = {};\nObject.defineProperty(obj, 'test', {\n　　set: (newVal)=>{\n　　　　document.getElementById('txt').value = newVal;\n　　　　document.getElementById('show_txt').innerHTML = newVal;\n　　}\n});\ndocument.addEventListener('keyup', (e)=>{\n　　obj.test = e.target.value;\n})\n"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"login.vue页面\n<template>\n  <div>\n    <input type=\"text\" v-model=\"loginForm.username\" placeholder=\"用户名\"/>\n    <input type=\"text\" v-model=\"loginForm.password\" placeholder=\"密码\"/>\n    <button @click=\"login\">登录</button>\n  </div>\n</template>\n \n<script>\nimport { mapMutations } from 'vuex';\nexport default {\n  data () {\n    return {\n      loginForm: {\n        username: '',\n        password: ''\n      },\n      userToken: ''\n    };\n  },\n \n  methods: {\n    ...mapMutations(['changeLogin']),\n    login () {\n      let _this = this;\n      if (this.loginForm.username === '' || this.loginForm.password === '') {\n        alert('账号或密码不能为空');\n      } else {\n        this.axios({\n          method: 'post',\n          url: '/user/login',\n          data: _this.loginForm\n        }).then(res => {\n          console.log(res.data);\n          _this.userToken = 'Bearer ' + res.data.data.body.token;\n          // 将用户token保存到vuex中\n          _this.changeLogin({ Authorization: _this.userToken });\n          _this.$router.push('/home');\n          alert('登陆成功');\n        }).catch(error => {\n          alert('账号或密码错误');\n          console.log(error);\n        });\n      }\n    }\n  }\n};\nstore文件夹下的index.js\n\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\n \nconst store = new Vuex.Store({\n \n  state: {\n    // 存储token\n    Authorization: localStorage.getItem('Authorization') ? localStorage.getItem('Authorization') : ''\n  },\n \n  mutations: {\n    // 修改token，并将token存入localStorage\n    changeLogin (state, user) {\n      state.Authorization = user.Authorization;\n      localStorage.setItem('Authorization', user.Authorization);\n    }\n  }\n});\nexport default store；\n\nrouter下的index.js页面\nimport Vue from 'vue';\nimport Router from 'vue-router';\nimport login from '@/components/login';\nimport home from '@/components/home';\n \nVue.use(Router);\n \nconst router = new Router({\n  routes: [\n    {\n      path: '/',\n      redirect: '/login'\n    },\n    {\n      path: '/login',\n      name: 'login',\n      component: login\n    },\n    {\n      path: '/home',\n      name: 'home',\n      component: home\n    }\n  ]\n});\n\nrouter.beforeEach((to, from, next) => {\n  if (to.path === '/login') {\n    next();\n  } else {\n    let token = localStorage.getItem('Authorization');\n \n    if (token === 'null' || token === '') {\n      next('/login');\n    } else {\n      next();\n    }\n  }\n});\n\nexport default router; \n\n请求头加token\n\n// 添加请求拦截器，在请求头中加token\naxios.interceptors.request.use(\n  config => {\n    if (localStorage.getItem('Authorization')) {\n      config.headers.Authorization = localStorage.getItem('Authorization');\n    }\n    return config;\n  },\n  error => {\n    return Promise.reject(error);\n\n  })\n\n"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以回避一些常见的问题。\n当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。\n这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。\n每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。\n检测变化的注意事项：\n受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：\nvar vm = new Vue({\n  data:{\n    a:1\n  }\n})\n// `vm.a` 是响应的\nvm.b = 2\n// `vm.b` 是非响应的\nVue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：\n\nVue.set(vm.someObject, 'b', 2)\n您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：\n\nthis.$set(this.someObject,'b',2)\n有时你想向一个已有对象添加多个属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，这样添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\n// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n\n声明响应式属性\n由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值：\n\nvar vm = new Vue({\n  data: {\n    // 声明 message 为一个空值字符串\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// 之后设置 `message`\nvm.message = 'Hello!'\n如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问的属性不存在。\n\n这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：data 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。\n\n异步更新队列\n可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。\n\n例如，当你设置 vm.someData = 'new value' ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。例如：\n\n<div id=\"example\">{{message}}</div>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：\n\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: '没有更新'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = '更新完成'\n      console.log(this.$el.textContent) // => '没有更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '更新完成'\n      })\n    }\n  }\n})\n因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：\n\nmethods: {\n  updateMessage: async function () {\n    this.message = 'updated'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n\n"}]