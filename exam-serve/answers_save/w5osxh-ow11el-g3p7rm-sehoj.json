[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"computed 多个值决定一个值，属性混入到Vue实例中\nwatch 一个值决定多个值，主要观察和响应Vue实例上的数据变化\nwatch主要是监听数据变化，可以监听数据来源的三个部分：props,data,computed内的数据，然后它还提供两个参数（new,old）,顺序一定是新值、旧值；无缓存性。 \ncomputed主要是处理逻辑运算，computed来存储需要处理的数据值，它有存储的机制，只有改变时才执行；具有缓存性，页面重新渲染值不变化。"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"        let $ = document.querySelector.bind(document);\n        let $txt = $(\"#txt\");\n        let $ShowTxt = document.getElementById('show-txt');\n\n        $txt.oninput = () => {\n            $ShowTxt.textContent = $txt.value\n        }\n"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":" <script>\n        import router from './router'\n        import {\n            getToken\n        } from '@/utils/auth' // getToken from cookie\n\n        const whiteList = ['/login', '/register', '/auth-redirect'] // no redirect whitelist\n\n        router.beforeEach((to, from, next) => {\n            if (getToken()) { // determine if there has token\n                // write your code here\n                if (to.path === '/login') {\n                    next({\n                        path: '/'\n                    })\n                }\n            } else {\n                // write your code here\n                next()\n            }\n        })\n    </script>"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"在这里用到了一个重要的思想就是发布订阅模式；Watcher初始化的时候会将Dep.target设置为this,也就是Watcher自己，同时会触发count的getter方法，getter里面会调用Dep的depend方法，depend方法会调用Watcher的addDep方法，addDep方法就是将Watcher自己存放在Dep的事件池里面。 当你把一个普通的javascript对象传给vue实例的data选项，vue将遍历此对象所有的属性，并使用object.defineProperty把这些属性全部转为getter/setter，通俗的说就是只要谁获取了counter的值就会触发getter()；要是谁改变了counter的值就会触发setter();比如上述代码中的button绑定{{count}}的时候一定会触发getter();如果是count的值发生改变就一定会触发setter()。每次数据改变就会触发-每个组件实例都有相应的watcher实例对象来订阅组件改变，他会在条件渲染过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使他关联的组件得以更新"}]