[{"title":"机器人归位","questions_id":"4t0rar-39c33-wq098t-phh5ht","json_path":"4t0rar-39c33-wq098t-phh5ht.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"在二维平面上，有一个机器人从原点 (0, 0) 开始，给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。\n\n移动顺序由字符串表示。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。\n\n示例 1:\n\n        输入: \"UD\"\n        输出: true\n        解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。\n\n示例 2:\n\n        输入: \"LL\"\n        输出: false\n        解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。\n\n\n注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。\n\n请根据题意在横线处填写合适的代码：\n\n\n  function check(str){\n            var U = 0, D = 0, L = 0, R = 0;\n            for(var i=0; i < str.length; i++){\n                switch (str[i]){\n                    case \"U\":______ ;break;\n                    case \"D\":______ ;break;\n                    case \"L\":______ ;break;\n                    case \"R\":______ ;break;\n                }\n            }\n            return ( ______ && ______ ) \n  }","student_answer":"class Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n        var x : Int = 0 , y : Int = 0\n        for move in moves.unicodeScalars {\n            switch move {\n            case \"L\": x -= 1\n            case \"R\": x += 1\n            case \"U\": y -= 1\n            case \"D\": y += 1\n            default: return false\n            }\n        }\n        return x == 0 && y == 0\n    }\n}\nclass Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n        let arr = moves.unicodeScalars\n        var v = 0, h = 0\n        for char in arr {\n            switch char {\n            case \"L\":\n                v = v + 1\n            case \"R\":\n                v = v - 1\n            case \"U\":\n                h = h + 1\n            case \"D\":\n                h = h - 1\n            default:\n                continue\n            }\n        }\n        \n        if v == 0 && h == 0 {\n            return true\n        } else {\n            return false\n        }\n    }\n}\nclass Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n        var x = 0\n        var y = 0\n        var hArray: [Int] = Array<Int>(repeating: 0, count: 86)\n        var vArray: [Int] = Array<Int>(repeating: 0, count: 86)\n        hArray[Int(\"L\".unicodeScalars.first!.value)] = 1\n        hArray[Int(\"R\".unicodeScalars.first!.value)] = -1\n\n        vArray[Int(\"U\".unicodeScalars.first!.value)] = 1\n        vArray[Int(\"D\".unicodeScalars.first!.value)] = -1\n        for i in moves.unicodeScalars {\n            let move = Int(i.value)\n            x += hArray[move]\n            y += vArray[move]\n        }\n        return x == 0 && y == 0\n    }\n}\nclass Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n               var x = 0\n        var y = 0\n        let arr = Array(moves)\n\n        for i in 0..<moves.count {\n            let move = arr[i]\n            switch move {\n            case \"U\":\n                y += 1\n            case \"D\":\n                y -= 1\n            case \"L\":\n                x += 1\n            case \"R\":\n                x -= 1\n            default: fatalError()\n            }\n        }\n        return x == 0 && y == 0\n    }\n}\nclass Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n             var x = 0\n        var y = 0\n        let hDic: [Character: Int] = [\"L\": 1, \"R\": -1]\n        let vDic: [Character: Int] = [\"U\": 1, \"D\": -1]\n        let arr = Array(moves)\n        let count = moves.count\n        for i in 0..<count {\n            let move = arr[i]\n            x += hDic[move] ?? 0\n            y += vDic[move] ?? 0\n        }\n        return x == 0 && y == 0\n    }\n}\nclass Solution {\n  func judgeCircle(_ moves: String) -> Bool {\n    var directions: [Character:Int] = [\n      \"U\" : 0,\n      \"D\" : 0,\n      \"L\" : 0,\n      \"R\" : 0\n    ]\n    for move in moves {\n      directions.updateValue(directions[move]! + 1, forKey: move)\n    }\n    return directions[\"U\"] == directions[\"D\"] && directions[\"L\"] == directions[\"R\"]\n  }\n}"},{"title":"创建一副扑克牌","questions_id":"4vu7t9-t9vv08-chvz3r-n8i3nq","json_path":"4vu7t9-t9vv08-chvz3r-n8i3nq.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。\n\n52张正牌又均分为13张一组，并以黑桃、红桃、梅花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。\n\n要求：根据以下数据生成一副扑克牌（数组）。\n\n    var types = [\"红桃\", \"黑桃\", \"方块\", \"梅花\"]; // 花色\n    var points = [\"A\", 2, 3, 4, 5, 6, 7, 8, 9, 10, \"J\", \"Q\", \"K\"]; // 点数\n    var cards = [\"大王\", \"小王\"]; // 所有扑克牌","student_answer":"struct puke\n{\n         charcolor;  //花色\n         charnumber[2]; //牌的数值\n         intflag;    //3,4...J Q K A 2 XW DW\n};\nstruct puke Card[54];  //加入大小王，54张，3人斗地主\nint card[54];        //每张牌对应的整数数组\n//如果按照card[52]排序,那么牌由小到大就是:A,2,3,4,5,6,7,8,9,10,J,Q,K \n//而牌由小到大排序是:3,4,5,6,7,8,9,10,J,Q,K,A,2 \n \n//*************************************************************\nvoid _shuffleCard()   //洗牌\n{\n         inti,j,k,temp;\n         for(i=0;i<4;i++)\n                   for(j=0;j<13;j++)\n                            card[i*13+j]=(i+1)*100+j+1;  //101 102...初始化牌的数组\n         card[52]=516;//小王大王\n         card[53]=517;\n         srand(time(NULL));   //产生随机数列的种子\n         for(i=0;i<54;i++)\n         {\n                   k=rand()%(53-i+1)+i;   //利用随机数打乱数组\n                   temp=card[i];\n                   card[i]=card[k];\n                   card[k]=temp;\n         }\n         cout<<endl;\n}\n \n \n//转换函数：card[52]->Card[52],将牌的存储由int类型转换为char类型\nvoid _turnCard()   //将数字转换成对应的花色的牌存入扑克数组\n{ \n         inti,temp;\n         for(i=0;i<54;i++)\n         {\n                   temp= card[i]%100; //取牌的数值，A为1 一直K 13\n                   Card[i].color= card[i]/100+'0';\n                   if(Card[i].color=='1')   //为了可视化的代替红黑方梅四种不同的花色\n                            Card[i].color='*';\n                   if(Card[i].color=='2')\n                            Card[i].color='&';\n                   if(Card[i].color=='3')\n                            Card[i].color='#';\n                   if(Card[i].color=='4')\n                            Card[i].color='~';\n                   if(Card[i].color=='5')\n                            Card[i].color='\\0';\n                   if(temp==1){\n                            Card[i].number[0]='A';\n                            Card[i].number[1]='\\0';\n                            continue;\n                   }\n                   if(temp==10){\n                            Card[i].number[0]='1';\n                            Card[i].number[1]='0';\n                            continue;\n                   }   \n                   if(temp==11){\n                            Card[i].number[0]='J';\n                            Card[i].number[1]='\\0';\n                            continue;\n                   }\n                   if(temp==12){\n                            Card[i].number[0]='Q';\n                            Card[i].number[1]='\\0';\n                            continue;\n                   }\n                   if(temp==13){\n                            Card[i].number[0]='K';\n                            Card[i].number[1]='\\0';\n                            continue;\n                   }\n                   if(temp==16){\n                            Card[i].number[0]='X';\n                            Card[i].number[1]='W';\n                            continue;\n                   }\n                   if(temp==17){\n                            Card[i].number[0]='D';\n                            Card[i].number[1]='W';\n                            continue;\n                   }\n \n                   Card[i].number[0]=temp+48;\n                   Card[i].number[1]='\\0';\n \n         }\n \n         for(i=0;i<54;i++)\n         {\n                   temp= card[i]%100; \n                   Card[i].flag= temp;\n                   if(temp==1||temp==2)   //A 2比 3,4,,,k 大\n                            Card[i].flag+=13;\n \n         }\n         //cout<<endl;\n \n}\n \n//*************************冒泡排序******************************\nvoid _sortCard() //二维数组，每层排序（即每个人18张牌排序）\n{\n         inti,j,k;\n         structpuke temp;\n         for(i=0;i<3;i++)\n         {\n                   for(j=0;j<18;j++)\n                            for(k=0;k<18-j-1;k++)\n                            {\n                                     if(Card[i*18+k].flag>Card[i*18+k+1].flag)\n                                     {\n                                               temp= Card[i*18+k];\n                                               Card[i*18+k]= Card[i*18+k+1];\n                                               Card[i*18+k+1]= temp;         \n                                     }\n                            }\n \n         }\n}\n \n/*\nvoid _print2()  //打印每个人的牌对应的数字\n{\n         inti = 0;\n         for(;i<54;i++)\n                   cout<<card[i]<<\"\";\n         cout<<endl;\n \n}\n*/\n \n/* void _print3()  //检测牌重复不\n{\n         inti = 0;\n         for(;i<54;i++)\n                   cout<<Card[i].flag<<\"\";\n         cout<<endl;\n \n}\n*/\n \n//********************************************\nvoid _printCard()  //打印每个人的牌\n{\n         inti,j;\n         for(i=0;i<3;i++){\n                   cout<<\"第\"<<i+1<<\"个人的牌：\";\n                   for(j=0;j<18;j++)\n                   {\n                            cout<<Card[i*18+j].color<<Card[i*18+j].number[0]<<Card[i*18+j].number[1]<<\"\";\n \n                   }\n                   cout<<endl;\n         }\n         cout<<endl;\n}\n \n \n \n//*****************************\nvoid _testCard() //验牌重复不\n{\n         inti,j,flag = 0;\n         for(i=0;i<54;i++)\n                   for(j=0;j<54-i-1;j++)\n                   {\n                            if(i!=j)\n                            {\n                                     if(card[i]==card[j])\n                                               flag= 1;\n                            }\n                   }\n                   if(flag==0)\n                            cout<<\"验证成功，无重复牌！\"<<endl;\n                   if(flag==1)\n                            cout<<\"验证失败，存在重复牌！\"<<endl;\n \n \n}\n \nint main()\n{\n         _shuffleCard();\n         _turnCard();\n         //  _print2();\n         //  _print3();\n         _sortCard();\n         _testCard();\n         _printCard();\n         system(\"pause\");\n         return0;\n}\n </span>\n"},{"title":"数据结构之对象","questions_id":"ma0uj-yctlrp-xjf87d-p2xrg","json_path":"ma0uj-yctlrp-xjf87d-p2xrg.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 请在 “其他“ 中查看图片。 \n \n\n\n请用一个合理的数据尽可能全面的描述图片中的物体","student_answer":""},{"title":"洗牌","questions_id":"npcnawn-0apvx-qbofy-ms3t4p","json_path":"npcnawn-0apvx-qbofy-ms3t4p.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"var pokers = [\"大王\", \"小王\", \"红桃A\", \"红桃2\", \"红桃3\", \"红桃4\", \"红桃5\", \"红桃6\", \"红桃7\", \"红桃8\", \"红桃9\", \"红桃10\", \"红桃J\", \"红桃Q\", \"红桃K\", \"黑桃A\", \"黑桃2\", \"黑桃3\", \"黑桃4\", \"黑桃5\", \"黑桃6\", \"黑桃7\", \"黑桃8\", \"黑桃9\", \"黑桃10\", \"黑桃J\", \"黑桃Q\", \"黑桃K\", \"方块A\", \"方块2\", \"方块3\", \"方块4\", \"方块5\", \"方块6\", \"方块7\", \"方块8\", \"方块9\", \"方块10\", \"方块J\", \"方块Q\", \"方块K\", \"梅花A\", \"梅花2\", \"梅花3\", \"梅花4\", \"梅花5\", \"梅花6\", \"梅花7\", \"梅花8\", \"梅花9\", \"梅花10\", \"梅花J\", \"梅花Q\", \"梅花K\"]\n\n补全以下代码完成洗牌逻辑：\n        \n        // 遍历 pokers 数组\n        for (var i = 0, len = cards.length; i < len; i++) {\n            // 生成一个随机的数组下标(0~53)\n            var index = Math.floor(___________ * len);\n            // 将当前遍历到的元素与随机下标处的元素交换位置\n            var tmp = cards[___________];\n            cards[i] = cards[index];\n            cards[___________] = tmp;\n        }\n        console.log(pokers)\n\n\n补全以下逻辑完成发牌操作（打乱的54张牌均分为三分）：\n\n        var first = cards.splice(0, 17);\n        var second = cards.splice(_______);\n        var third = cards._______(_______ , _______);","student_answer":"int i=0;\nint current=1;//当前摸牌人\nfor(i=0;i<54;i++)\ntags[i]=0;\nfor(i=0;i<51;i++)\n{\nRandom rm=new Random();\nint temp=rm.nextInt(54);\nif(tags[temp]!=0)\n{\ni--;\ncontinue;\n}\nelse\n{\ntags[temp]=current%3+1;\ncurrent++; \n}\n}\nshowW(1);showW(2);showW(3);showW(0);\n\n}\nprivate static void showW(int w)\n{\nint i=0;\nif(w==0)\nSystem.out.print(\"底牌：\");\nelse\nSystem.out.print(\"玩家\"+w+\"：\");\nfor(i=0;i<54;i++)\n{\nif(tags[i]==w)\nSystem.out.print(cards[i]+\" \");\n}\nSystem.out.println();\n}\n\n\n}\n"}]