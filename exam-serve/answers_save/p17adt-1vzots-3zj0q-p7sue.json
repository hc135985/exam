[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"1.comouted计算属性只有在相关的数据发生变化时才会改变要计算的属性，在数据未发生变化时，优先读取缓存。\n2.watch方法 在数据变化时来执行异步操作\n3.尽量用computed计算属性来监视数据的变化，因为它本身就这个特性，用watch没有computed“自动”，手动设置使代码变复杂。"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"var obj = {};\nObject.defineProperty(obj, 'test', {\n　　set: (newVal)=>{\n　　　　document.getElementById('txt').value = newVal;\n　　　　document.getElementById('show_txt').innerHTML = newVal;\n　　}\n});\ndocument.addEventListener('keyup', (e)=>{\n　　obj.test = e.target.value;\n})"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"import router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n     let service = to.query.service\n      if (service !== undefined) {\n      //  存在service参数，则说明是子系统传递过来的，cas是不需要的。\n        let serviceArr = JSON.parse(localStorage.getItem('service'))\n        if (serviceArr !== null) {\n          serviceArr.push(service.replace('login', 'logout'))\n        } else {\n          serviceArr = []\n          serviceArr.push(service.replace('login', 'logout'))\n        }\n        localStorage.setItem('service', JSON.stringify(_.uniq(serviceArr)))\n       // 校验token，如果校验通过，则进行页面重定向\n        verify(getToken()).then(response => {\n          window.location.href = service + '?ticket=' + getToken()\n        }).catch(error => {\n          console.log(error)\n          store.dispatch('LogOut').then(() => {\n            window.location.href = service\n          })\n        })\n        return\n  } else {\n    // write your code here\n    f (store.getters.user === undefined) {\n          store.dispatch('GetInfo').then(info => {\n            console.log(info)\n            let userId = store.getters.user.id\n            store.dispatch('GetQuickEntry', userId).then(info => {\n              store.dispatch('GetSystem', userId).then(info => {\n                next({ path: '/index' })\n              })\n            })\n          }).catch(() => {\n          })\n        } else {\n          next()\n        }\n      }\n    } else {\n      if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n        next()\n      } else {\n        next('/login') // 否则全部重定向到登录页\n        NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n      }\n    }\n  }\n  }\n})"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"Vue 采用声明式编程替代过去的类 Jquery 的命令式编程，并且能够侦测数据的变化，更新视图。\n这使得我们可以只关注数据本身，而不用手动处理数据到视图的渲染，避免了繁琐的 DOM 操作，提高了开发效率。\nVue 数据响应核心就是使用了 Object.defineProperty 方法（ IE9 + ) 。\nvue 的响应式系统依赖于三个重要的类：Dep 类、Watcher 类、Observer 类。\nDep 类作为发布者的角色\nWatcher 类作为订阅者的角色\nObserver 类则是连接发布者和订阅者的纽带，决定订阅和发布的时机。\n\n一.数据的定义:\n    组件中定义数据{counter:0}；\n    初始化过程中，会执行observe(data, this)；\n    在observe（）过程中会将data这个对象劫持，\n    通过Object.defineProperty将data上所有的属性绑定上getter和setter函数;\n\t  (这是针对对象，对于数组，Vue通过改写数组的原生方法来劫持)；\n    通俗的说就是只要谁获取了counter的值就会触发getter()；\n    要是谁改变了counter的值就会触发setter();\n\n二.数据绑定:\n    在页面元素button中绑定{{count}};\n    在编译过程中，针对这个button会产生一个Watcher(vm, exp, cb(newValue,oldValue)),\n    vm是Vue对象，exp是数据绑定的数据;cb（）的逻辑是用来更新页面。\n    现在的问题是如何将数据的变化和Watcher关联起来。\n    在这里用到了一个重要的思想就是发布订阅模式；\n    Watcher初始化的时候会将Dep.target设置为this,也就是Watcher自己，\n    同时会触发count的getter方法，getter里面会调用Dep的depend方法，\n    depend方法会调用Watcher的addDep方法，addDep方法就是将Watcher自己存放在Dep的事件池里面。\n\n三.数据响应:\n    当发生点击事件的时候，count的值改变，会触发setter里面的方法，这个方法会调用dep.notify()；\n    它会告知Dep的事件池里的存放的Watcher去执行它的update（）方法；\n    Watcher的update()方法；这个方法里面会获取count的新的值，给它的回调cb()，去更新视图\n"}]