[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"watch属性可以用来监听data属性中数据的变化,还可以被用来监听路由router的变化\nwatch 一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是 computed 和 methods 的结合体\nWatch：当你需要在数据变化响应时，执行异步操作，或高性能消耗的操作，自定义 watcher 的方式就会很有帮助\ncomputed属性的作用与watch类似，也可以监听属性的变化,只是他会根据他依赖的属性，生成一个属性，让实例可以使用这个属性\ncomputed 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用\nComputed: 可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会出发这个属性。具有缓存能力，所以只有当数据再次改变时才会重新渲染，否则就会直接拿取缓存中的数据"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"let txt = document.querySelector('#txt'),\nshowTxt = document.querySelector('#show-txt');\ntxt.oninput = () => {\n   showTxt.innerHTML= txt.value \n}\n/*****************************/\n\nlet vals = {\n           _val : null\n       },\n       txt = document.querySelector('#txt'),\n       showTxt = document.querySelector('#show-txt');\n        Object.defineProperty(vals, 'val', {\n                set: function (newVal) {\n                    this._val = newVal;\n                    showTxt.innerHTML = newVal\n                },\n                get: function () {\n                    return txt.value\n                }\n            })\n\n        txt.oninput = () => {\n            vals.val= txt.value \n        }"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"router.beforeEach(function (to, from, next) {\n                    if (false) { //false表示没登陆，true表示登陆\n                        if (to.meta.r) {//表示是否需要权限验证\n                                next()\n                            } else {\n                                if (to.path == \"/login\") {\n                                    next()\n                                } else {\n                                    alert(\"没有权限,请用管理员登陆\")\n                                    next({ path: '/login' })\n                                }\n                            }\n                    } else {\n                        //to.path != \"/login\" ? next({ path: '/login' }) : next()\n                        if (to.path == \"/login\") {\n                            next({ path: '/' })\n                        }else{\n                            next()\n                        }\n                    }\n                })"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"Vue 采用声明式编程，且能够侦测数据的变化，更新视图。这使得我们可以只关注数据本身，而不用手动处理数据到视图的渲染，避免了繁琐的 DOM 操作，提高了开发效率。\nVue 数据响应核心就是使用了 Object.defineProperty\nvue 的响应式系统依赖于三个重要的类：Dep 类、Watcher 类、Observer 类。\nDep 类作为发布者的角色，Watcher 类作为订阅者的角色，Observer 类则是连接发布者和订阅者的纽带，决定订阅和发布的时机\nObserver, 观察者，用来观察数据源变化. \nDep, 观察者和订阅者是典型的 一对多 的关系,所以这里设计了一个依赖中心,来管理某个观察者和所有这个观察者对应的订阅者的关系, 消息调度和依赖管理都靠它。 \nWatcher, 订阅者，当某个观察者观察到数据发生变化的时候，这个变化经过消息调度中心，最终会传递到所有该观察者对应的订阅者身上，然后这些订阅者分别执行自身的业务回调即可 \nObserver 类中，为 data 的每个属性都实例化一个 Dep 类，即发布者。并且在取值时让订阅者（有多个，因为 data 中的每个属性都可以被应用在多个地方）订阅，在赋值时发布者发布通知，让订阅者做出各自的响应\nDep.target是 Watcher 类的实例, Watcher 类在构造函数中执行了一个 getValue 方法，将自己赋值给 Dep.target ，并且执行了取值操作，这样就成功的完成了订阅操作。一旦数据发生变化，即有了赋值操作，发布者就会发送通知，订阅者就会执行自己的 update 方法来响应这次数据变化\n数据和视图之间的同步，视图随着数据变化而变化，反之亦然。 Vue 是支持数据的双向绑定的，主要应用于表单，是通过 v-model 指令来实现的。 v-model 指令的节点监听相应的事件，在事件回调中来改变相应的数据。这一切都 Compile 类中完成，假设有一个 input 标签应用了 v-model 指令，在开始编译模板时，遇到 v-model 指令时会执行：更新 dom 节点的值，订阅者订阅，事件监听\n简单来说就是， 观察者观察数据状态变化, 一旦数据发生变化，则会通知对应的订阅者，让订阅者执行对应的业务逻辑 。"}]