[{"title":"computed 和 watch 区别","questions_id":"joo9h2-q79phw-pskuido-ua4t7k","json_path":"joo9h2-q79phw-pskuido-ua4t7k.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"computed 和 watch 区别?\n\n\n\n\n\n\n\n\n\n\n\n","student_answer":"computed\n计算结果并返回，只有当被计算的值发生改变时才会触发 \n(即：计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算)\nnew Vue({\n    el: '#id',\n    template: `<div>\n        <span>Name: {{name}}<span>\n    </div>`,\n    data: {\n        firstName: 'Leo',\n        lastName: 'Alan'\n    },\n    computed: {\n        name () {\n            return `${this.firstName} + ${this.lastName}`\n        }\n    }\n})\nwatch\n监听某一个值，当被监听的值发生变化时，执行对应的操作 \n(与computed的区别是，watch更加适用于监听某一个值的变化并做对应的操作，比如请求后台接口等，而computed适用于计算已有的值并返回结果)\n\nnew Vue({\n    el: '#id',\n    template: `<div>\n        // ...\n    </div>`,\n    data: {\n        firstName: 'Leo',\n        lastName: 'Alan',\n        obj1: {\n            a: 0\n        }\n    },\n    watch: {\n        // 监听firstName,当firstName发生变化时就会执行该函数\n        firstName () {\n            // 执行需要的操作...\n            // 注:初始化不会执行，只有当被监听的值(firstName)发生变化时才会执行\n        },\n\n        // 监听lastName\n        lastName: {\n            handler (newName, oldName) {\n                // 执行需要的操作...\n            },\n            immediate: true // true: 初始化时就会先执行一遍该监听对应的操作    \n        },\n\n        obj1: {\n            handler () {\n                // 执行需要的操作...\n            },\n            deep: true // 该属性默认值为false. \n            // 当被监听的值是对象,只有deep为true时,对应属性的值(obj1.a)发生变化时才能触发监听事件，但是这样非常消耗性能\n        },\n\n        // 监听对象具体的属性， deep就不需要设置为true了\n        'obj1.a': {\n            handler () {\n                // 执行需要的操作...\n            }\n        }\n\n    }\n})"},{"title":"实现双向数据绑定","questions_id":"nodsz-nme56x-51nrc-tklsfn","json_path":"nodsz-nme56x-51nrc-tklsfn.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"liuyu","user_id":"kqpvys-hpzkdt","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"使用js实现一个数据双向绑定效果, input中输入的内容同步到p标签中\n```\n<div id=\"app\">\n    <input type=\"text\" id=\"txt\">\n    <p id=\"show-txt\"></p>\n</div>\n```","student_answer":"<body>\n    <div id=\"app\">\n        <input type=\"text\" id=\"txt\" v-model=\"str\">\n        <p id=\"show-txt\">{{str}}</p>\n    </div>\n    <script src = \"vue.min.js\"></script>\n    <script>\n        new Vue({\n            el:\"#app\",\n            data:{\n                str:\"halou\"\n            }\n        })\n        \n    </script>\n</body>"},{"title":"Vue导航守卫做鉴权处理","questions_id":"42cuvb-7216fb-zlkab2-wwns3d","json_path":"42cuvb-7216fb-zlkab2-wwns3d.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 在Vue中我们可以使用导航守卫做鉴权，现有要求如下：  \n可以根据getToken()是否返回token判断  \n- 1.如果用户已经登陆  \n  - a. 如果用户要去/login页面，则重定向到/路径  \n  - b. 如果用户要去其他页面，则不做处理直接跳转    \n- 2.如果用户未登陆  \n  - a. 如果用户要去的页面在白名单内，则不做处理直接跳转  \n  - b. 如果用户要去的页面不在白名单内，则重定向到/login页面，并把要去的页面路径作为查询字符串的query的值\n\n```js\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // determine if there has token\n    // write your code here\n  } else {\n    // write your code here\n  }\n})\n```","student_answer":"//全局守卫，记录登录状态\nimport router from './router'\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nconst whiteList = ['/login', '/register', '/auth-redirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  if (getToken()) { // 判断是否有token\n    if (to.meta.roles && to.meta.roles.indexOf(user.role) === -1) {\n    \talert('403')\n    \tif(from.path == '/login'){\n    \t\tnext('/')\n    \t}else{\n    \t\tnext({path: from.path})\n    \t}\n    } else {//页面没有权限要求就直接访问\n    \tnext()\n    }\n  } else if(to.path != '/login'){//没有token的话让跳转到登录页，并传递当前准备访问的路由\n      next({path:'/login', query: {redirect: to.fullPath}})\n  } else{\n  \tnext()\n  }\n})"},{"title":"Vue基础知识","questions_id":"uecyx-3qim4-rwk9o-v43sj8","json_path":"uecyx-3qim4-rwk9o-v43sj8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"wbxm4-jf8q6k-lvt2ca-ze96mg","exam_name":"月考","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈对Vue响应原理的理解?","student_answer":"vue将data初始化为一个Observer并对对象中的每个值，重写了其中的get、set，data中的每个key，都有一个独立的依赖收集器。\n在get中，向依赖收集器添加了监听\n在mount时，实例了一个Watcher，将收集器的目标指向了当前Watcher\n在data值发生变更时，触发set，触发了依赖收集器中的所有监听的更新，来触发Watcher.update"}]