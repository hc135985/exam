[{"title":"使用类实现任务调度","questions_id":"sue8v-wa50ws-jss7qm-592yt8","json_path":"sue8v-wa50ws-jss7qm-592yt8.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 使用js实现以下效果 \nvar priorityQueue = new PriorityQueue();  \npriorityQueue.enqueue('优先级1-1', 1);  \npriorityQueue.enqueue('优先级3-1', 3);  \npriorityQueue.enqueue('优先级1-2', 1);  \npriorityQueue.enqueue('优先级2-1', 2);  \npriorityQueue.print();  \n// 优先级1-1 优先级1-2 优先级2-1 优先级3-1 priorityQueue.dequeue();   \n```js\nclass PriorityQueue{\n    constuctor(obj){\n        this.arr=[];\n    }\n    enqueue(str,num){\n        // write your code here\n    }\n    print(){\n       // write your code here \n    }\n}\n```","student_answer":"   var priorityQueue = new PriorityQueue();\n        priorityQueue.enqueue('优先级1 - 1', 1);\n        priorityQueue.enqueue('优先级3 - 1', 3);\n        priorityQueue.enqueue('优先级1 - 2', 1);\n        priorityQueue.enqueue('优先级2 - 1', 2);\n        priorityQueue.print();\n        // 优先级1-1 优先级1-2 优先级2-1 优先级3-1 priorityQueue.dequeue();\n\n        class PriorityQueue {\n            constuctor(obj) {\n                this.arr = [];\n                init()\n            }\n            init() {\n                this.enqueue(str, num)\n                this.print()\n                this.isEmpty()\n            }\n            enqueue(str, num) {\n                // write your code \n                var queueElement = new enqueue(element, priority);\n                if (isEmpty()) {\n                    items.push(queueElement)\n                } else {\n                    var added = false;\n                    for (var i = 0; i < items.length; i++) {\n                        if (queueElement.priority < items[i].priority) {\n                            items.splice(i, 0, queueElement);\n                            added = true;\n                            break\n                        }\n                    }\n                    if (!added) {\n                        items.push(queueElement)\n                    }\n                }\n            }\n            print() {\n                // write your code here \n                console.log(items.toString())\n            }\n            isEmpty = function() {\n                return items.length == 0;\n            }\n        }"},{"title":"react生命周期","questions_id":"xt05yo-prna5g-f7zqo-ltl5rh","json_path":"xt05yo-prna5g-f7zqo-ltl5rh.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"# react常用生命周期图\n\n## 请在 “其他“ 中查看图片。 \n \n\n\n如图是react常用生命周期图，请阅读图，并在1，2，3，4处填写对应的生命周期","student_answer":"\nvar React = require(\"react\");\nvar ReactDOM = require(\"react-dom\");\n \nvar List = React.createClass({\n    //1.创建阶段\n    getDefaultProps:function() {\n        console.log(\"getDefaultProps\");\n        return {};\n    },\n    //2.实例化阶段\n    getInitialState:function() {\n        console.log(\"getInitialState\");\n        return {};\n    },\n  //render之前调用，业务逻辑都应该放在这里，如对state的操作等\n  componentWillMount(){\n    //它在 render() 方法之前被调用。这就是为什么它可以用作去设置组件内部的状态，因为它不会触发组件的再次渲染。但一般来说，还是推荐在constructor() 中去初始化状态。\n  \t},\n \tcomponentWillReceiveProps(nextProps) {\n    \t//这个方法在一个更新生命周(updatelifecycle) 中被调用。新的属性会作为它的输入。因此你可以利用 this.props 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为。此外，你可以基于新的属性 来设置组件的状态。\n    }，\n  shouldComponentUpdate(nextProps, nextState) {\n\t\t//每次组件因为状态或者属性更改而更新时，它都会被调用。你将在成熟的 React 应用中使用它来进行性能优化。在一个 更新生命周期中，组件及其子组件将根据该方法返回的布尔值来决定是否重新渲染。 这样你可以阻止组件的渲染生命周期(render lifecycle)方法，避免不必要的渲染\n\t},\n    //渲染并返回一个虚拟DOM\n    render:function() {\n        console.log(\"render\");\n        return(\n            <div> hello <strong> {this.props.name} </strong></div>\n            );\n    },\n \n    //该方法发生在render方法之后。在该方法中，ReactJS会使用render生成返回的虚拟DOM对象来创建真实的DOM结构\n    componentDidMount:function() {\n        console.log(\"componentDidMount \");\n    },\n     componentWillUpdate(nextProps, nextState) {\n      //这个方法是 render() 执行之前的最后 一个方法。你已经拥有下一个属性和状态，它们可以在这个方法中任由你处 置。你可以利用这个方法在渲染之前进行最后的准备。注意在这个生命周期方法中你不能再触发 setState()。如果你想基于新的属性计算状态，你必须利用 \n      },\n     componentDidUpdate(prevProps, prevState) {\n       //这个方法在 render() 之后立即调用。你可以用它当成操作 DOM 或者执行更多异步请求的机会。\n      }\n  \tcomponentWillUnmount() {\n  \t\tconsole.log(\"componentWillUnmount 组件销毁阶段\")\n      //它会在组件销毁之前被调用。你可以利用这个生命周期 方法去执行任何清理任务\n    }\n\tcomponentDidCatch(error, info){\n    //错误处理\n    } \n});\nReactDOM.render(<List name=\"ReactJS\">children</List>, document.body)\n                \n                \n                \nconstructor (构造函数)\n\n只有在组件实例化并插入到 DOM 中的时候才会被调用。组件实例 化的过程称作组件的挂载(mount)。 \n它在组件初始化时被调用。在这个方法中，你可以设置初始化状态以及绑定类方法。\n\ncomponentWillMount()\n\n它在 render() 方法之前被调用。这就是为什么它可以用作去设置组件内部的状态，因为它不会触发组件的再次渲染。但一般来说，还是推荐在constructor() 中去初始化状态。\n\nrender()\n\n该方法会在组件被挂载过程中被调用，同时当组件被更新的时候也会被调用，每当组件的状态 （state）或属性 （props）改变时，组件的 render() 方法都会被调用 \n这个生命周期方法是必须有的，它返回作为组件输出的元素。这个方法应该是一个纯函数，因此不应该在这个方法中修改组件的状态。它把属性和状态作为输入并且返回(需要渲染的)元素\n\ncomponentDidMount() \n它仅在组件挂载后执行一次。这是发起异步请求去 API 获取 数据的绝佳时期。获取到的数据将被保存在内部组件的状态中然后在 render() 生命 周期方法中展示出来。\n\ncomponentWillReceiveProps(nextProps) \n这个方法在一个更新生命周(updatelifecycle) 中被调用。新的属性会作为它的输入。因此你可以利用 this.props 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为。此外，你可以基于新的属性 来设置组件的状态。\n\nshouldComponentUpdate(nextProps, nextState) \n每次组件因为状态或者属性更改而更新时，它都会被调用。你将在成熟的 React 应用中使用它来进行性能优化。在一个 更新生命周期中，组件及其子组件将根据该方法返回的布尔值来决定是否重新渲染。 这样你可以阻止组件的渲染生命周期(render lifecycle)方法，避免不必要的渲染。\n\ncomponentWillUpdate(nextProps, nextState) \n这个方法是 render() 执行之前的最后 一个方法。你已经拥有下一个属性和状态，它们可以在这个方法中任由你处 置。你可以利用这个方法在渲染之前进行最后的准备。注意在这个生命周期方法中你不能再触发 setState()。如果你想基于新的属性计算状态，你必须利用 componentWillReceiveProps()。\n\ncomponentDidUpdate(prevProps, prevState) \n这个方法在 render() 之后立即调用。你可以用它当成操作 DOM 或者执行更多异步请求的机会。\n\ncomponentWillUnmount() \n它会在组件销毁之前被调用。你可以利用这个生命周期 方法去执行任何清理任务。\n\ncomponentDidCatch(error, info) 错误处理\n               \n                \n                \n                \n             "},{"title":"性能优化","questions_id":"00a1t8-ezqkxg-xv9pkk-6hqfyb","json_path":"00a1t8-ezqkxg-xv9pkk-6hqfyb.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"请用js实现一个监听浏览器窗口变化的函数，当浏览器窗口的宽度大于等于 600px 的时候console.log('hello')（持续大于等于600px的话打印一次即可），请用你觉得最优的实现","student_answer":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    \n    <script>\n       \n\n\nwindow.onload=function (){\n    changeDiv_qiyunkai()\n}\nwindow.onresize=function(){\n    changeDiv_qiyunkai()\n}\nfunction changeDiv_qiyunkai(){\n    var H=document.documentElement.clientWidth;\n    if(H>=600){\n        console.log('hello','大于等于600px 打印一次 hello')\n        overChange()\n    }else{\n        console.log('未达到600px')\n        return false\n    }\n\n}\n\n\nfunction overChange(){\n \t\t window.onresize=function(){\n            return false\n        }\n        window.onload=function (){\n            return false\n        }\n}\n    </script>\n</body>\n\n</html>"},{"title":"async配合transition实现自定义动画","questions_id":"bqq54a-jly2z9-m9fg7pj-oio193","json_path":"bqq54a-jly2z9-m9fg7pj-oio193.json","subject_text":"项目实战","subject_id":"94sjh6-lnlxe","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"w916peach","user_id":"axg8t2-oroeja","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"html结构\n```html\n<div id=\"box\"></div>\n```\ncss样式\n```css\n#box{\n  width:100px; height:100px; background-color:red; border-radius:50%; transition:transform 0.5s;\n}\n```\njavaScript代码\n```js\n        const oBox = document.getElementById('box');\n        oBox.addEventListener('transitionend',()=>{\n            let {x,y} = oBox;\n            moveTo.reslove({x,y});\n        },false);\n        function moveTo(x,y){\n            return new Promise((reslove,reject)=>{\n                moveTo.reslove = reslove;\n                oBox.x = x;\n                oBox.y = y;\n                oBox.style.transform = `translate(${x}px,${y}px)`;\n            })\n        }\n```\n\n补全以上代码，使点击oBox后，使oBox走出一个  W 的轨迹（使用async函数实现），并简单写出整体的代码思路。","student_answer":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta content=\"width=device-width, initial-scale=1.0\"\n        name=\"viewport\">\n  <meta content=\"ie=edge\"\n        http-equiv=\"X-UA-Compatible\">\n  <title>Document</title>\n  <style>\n        #box {\n            width: 100px;\n            height: 100px;\n            background-color: red;\n            border-radius: 50%;\n            transition: transform 0.5s;\n        }\n  </style>\n</head>\n<body>\n  <div id=\"box\"></div>\n  <script>\n        const oBox = document.getElementById('box');\n        oBox.addEventListener('transitionend', () => {\n            let {\n                x,\n                y\n            } = oBox;\n            moveTo.reslove({\n                x,\n                y\n            });\n        }, false);\n\n        function moveTo(x, y) {\n            return new Promise((reslove, reject) => {\n                moveTo.reslove = reslove;\n                oBox.x = x;\n                oBox.y = y;\n                oBox.style.transform = `translate(${x}px,${y}px)`;\n            })\n        }\n        async function func() {\n\n            await moveTo(10, 10)\n            await moveTo(20, 20)\n            await moveTo(10, 30)\n            await moveTo(20, 40)\n            await moveTo(10, 50)\n\n        }\n\n        func()\n  </script>\n</body>\n</html>\n"}]