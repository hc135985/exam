[{"title":"性能优化","questions_id":"00a1t8-ezqkxg-xv9pkk-6hqfyb","json_path":"00a1t8-ezqkxg-xv9pkk-6hqfyb.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"请用js实现一个监听浏览器窗口变化的函数，当浏览器窗口的宽度大于等于 600px 的时候console.log('hello')（持续大于等于600px的话打印一次即可），请用你觉得最优的实现","student_answer":"  window.onresize=function(){\n            let width=document.body.clientWidth;\n            let index=1\n            if(width>=60){\n  \t\t        console.log('hello')\n            }\n        }"},{"title":"多种组件创建方式及其区别？","questions_id":"cbssqf-16avt7-qwk8k-ufilrc","json_path":"cbssqf-16avt7-qwk8k-ufilrc.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 多种组件创建方式及其区别？","student_answer":"组件三种创建方式:\n\t无状态组件\t\n   React.createClass  \n\textends React.Component\n区别:\n\t无状态组件:创建纯展示组件，只负责根据传入的props来展示，不涉及state状态操作，组件不会被实例化，组件不能访问this对象，组件无法访问生命周期函数，只能访问props\n    React.createClass:es5原生创建，有状态，可以访问组件的生命周期函数\n    extends React.Component:es6创建，有状态，可以访问组件的生命周期函数，最终取代React.createClass\n\tReact.createClass 和 extends React.Component的区别：1.函数this自绑定2.propTypes和defaultProps配置不同"},{"title":"封装图片加载Promise","questions_id":"gt8z4u-ufd66j-najaef-y8ytir","json_path":"gt8z4u-ufd66j-najaef-y8ytir.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 封装加载图片的promise  \n```js\nlet loadImg = (src)=>{\n    return new Promise((resolve, reject)=>{\n        // write your code here\n    })\n}\n```\n","student_answer":"const loadImg = (src) => {\n    // 初始化设置参数\n    let sourceData = src.sourceData\n    let mode = src.mode || false\n    let target = src.target || []\n    let needRes = src.response || false\n    // 创建promise对象\n    let promise = new Promise((resolve, reject) => {\n        // 资源加载进度\n        let loadNum = 0\n        // 资源加载的结果集\n        let response = {}\n        // 如果是非严格模式\n        if (mode === false) {\n            // 遍历加载每个资源\n            Object.keys(sourceData).forEach(key => {\n                let source = new Image()\n                // 失败或者成功都写入response\n                source.onload = source.onerror = () => {\n                    response[key] = source\n                    loadNum++\n                    if (loadNum === Object.keys(sourceData).length) {\n                        // 如果有目标对象\n                        if (target) {\n                            target.forEach((item, index) => {\n                                item.src = Object.values(sourceData)[index]\n                            })\n                        }\n                        // 成功\n                        resolve(response)\n                    }\n                }\n               // src的赋值放在onload和onerror事件后面，这样才能兼容IE\n                source.src = sourceData[key]\n            })\n        } else if (mode === true) {  // 严格模式：一个失败直接结束且返回空对象\n            // 遍历加载每个资源\n            Object.keys(sourceData).forEach(key => {\n                let source = new Image()\n                // 成功则写入response\n                source.onload = () => {\n                    response[key] = source\n                    loadNum++\n                    if (loadNum === Object.keys(sourceData).length) {\n                        // 如果有目标对象\n                        if (target) {\n                            target.forEach((item, index) => {\n                                item.src = Object.values(sourceData)[index]\n                            })\n                        }\n                        resolve(response)\n                    }\n                }\n                // 失败则返回空\n                source.onerror = () => {\n                    // 失败\n                    reject({})\n                }\n                // src的赋值必须放在最后，兼容IE\n                source.src = sourceData[key]\n            })\n        }\n    })\n    // 结束\n    if (needRes) {\n        return promise\n    }\n}"}]