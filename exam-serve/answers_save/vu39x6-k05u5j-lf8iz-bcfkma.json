[{"title":"匿名自执行函数的应用","questions_id":"vh80e-3d3g3o-6hy47e-ib2x4c","json_path":"vh80e-3d3g3o-6hy47e-ib2x4c.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"heinan","user_id":"fdjfr-msxp8a","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"代码如下：\n```js\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function () {\n        console.log(i)\n    })\n}\n输出\n5\n5\n5\n5\n5\n```\n修改上面代码，打印结果要求为：0,1，2，3，4","student_answer":"for (let i = 0; i < 5; i++) {\n            setTimeout(function () {\n                console.log(i)\n            })\n        }\n\nfor (var i = 0; i < 5; i++) {\n   setTimeout((function(n){\n      console.log(n)\n  　 })(i))\n }\n\n"},{"title":"react生命周期","questions_id":"xt05yo-prna5g-f7zqo-ltl5rh","json_path":"xt05yo-prna5g-f7zqo-ltl5rh.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"# react常用生命周期图\n\n## 请在 “其他“ 中查看图片。 \n \n\n\n如图是react常用生命周期图，请阅读图，并在1，2，3，4处填写对应的生命周期","student_answer":" 1, shouldComponentUpdate\n 2, componentDidMount\n 3, componentDidUpdate\n 4, ..."},{"title":"多种组件创建方式及其区别？","questions_id":"cbssqf-16avt7-qwk8k-ufilrc","json_path":"cbssqf-16avt7-qwk8k-ufilrc.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 多种组件创建方式及其区别？","student_answer":"React 创建组件有三种方式\n一,函数式定义的无状态组件\n无状态组件其组件不会被实例化，整体渲染性能得到提升, 组件不能访问this对象, 组件无法访问生命周期的方法, 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用\n总的来说无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件\n\n二,es5原生方式React.createClass定义的组件\n这种组件是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件.是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法,会自绑定函数方法而导致不必要的性能开销，增加代码过时的可能性。而且其mixins不够自然、直观.\n\n三,es6形式的extends React.Component定义的组件\n这种组件是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用\n\nReact.createClass与React.Component区别\n函数this自绑定: React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。React.Component有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用method.bind(this)来完成绑定，还可以使用arrow function来绑定。\n\n组件属性类型propTypes及其默认props属性defaultProps配置不同\nReact.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的. React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的. \n\n组件初始状态state的配置不同\nReact.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态, 而React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。\n\nMixins的支持不同\nMixins(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用。React.createClass在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。React.Component这种形式并不支持Mixins, 但是React开发者社区提供一个全新的方式来取代Mixins,那就是Higher-Order Components\n\nReact.createClass最终会被React.Component的类形式所取代。但是在找到Mixins替代方案之前是不会废弃掉React.createClass形式,能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。只要有可能，尽量使用无状态组件创建形式。否则（如需要state、生命周期方法等），使用`React.Component`这种es6形式创建组件, 而且无状态组件内部其实是可以使用ref功能的，虽然不能通过this.refs访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。"},{"title":"分别使用DOM0级DOM2级给一个DIV绑定事件","questions_id":"1gsxn-k09c2j-gq8peo-sohe9","json_path":"1gsxn-k09c2j-gq8peo-sohe9.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"renyuliang","user_id":"bsz88g-071r5","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"分别使用DOM0级DOM2级给一个button绑定事件，并且描述这两种方式的区别","student_answer":"DOM 0级\n<input id=\"btn\" type=\"button\" onclick=\"console.log('You clicked  by dom0!');\" value=\"Click\" />\nDOM 2级\ndocument.getElementById('btn').addEventListener('click', function() {\n      console.log('I am processed by dom2!');\n });\n\n区别: \nDOM0级可以在标签内写onclick事件, 也可以在JS写onlicke=function（）{}函数, 而DOM2级则只有一个监听方法，原生有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener(),且只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段\n如果定义了两个dom0级事件，dom0级事件会覆盖, dom2不会覆盖，会依次执行,dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖\nDOM0级事件处理方式就是讲一个函数赋值给一个事件处理属性, 且只能触发事件冒泡阶段不能触发事件捕获阶段。 而DOM2级事件对于精确的元素不区分事件捕获和事件冒泡，事件的执行顺序是按照绑定顺序来的。且DOM2级事件绑定不是给元素添加属性是直接添加的事件.\n"},{"title":"最少两种方式实现点击每个li都弹出下标","questions_id":"puaqas-1modca-2y04jh-brcz59g","json_path":"puaqas-1modca-2y04jh-brcz59g.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"renyuliang","user_id":"bsz88g-071r5","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"<ul id=”test”>\n    <li>这是第一条</li>\n    <li>这是第二条</li>\n    <li>这是第三条</li>\n</ul>","student_answer":"方法一\nvar itemli = document.getElementsByTagName(\"li\");\n   for(var i = 0; i<itemli.length; i++){\n　　　　itemli[i].index = i; //给每个li定义一个属性索引值\n　　　　itemli[i].onclick = function(){\n　　　　　　alert(this.index); \n　　　　}\n   }\n\n方法二\nvar itemli = document.getElementsByTagName(\"li\");\nfor(var i = 0; i<itemli.length; i++){\n　　　(function(n){\n       itemli[i].onclick = function(){\n　　　　　　alert(n);  \n　　　　　}\n  　　})(i)\n   }\n\n方法三\nvar itemli = document.getElementsByTagName(\"li\");\nfor(let i = 0; i<itemli.length; i++){\n　　itemli[i].onclick = function(){\n　　　alert(i);  \n   }\n  \n方法四\nvar itemli = document.getElementsByTagName(\"li\");\nfor(var i = 0; i<itemli.length; i++){\n        itemli[i].onclick = function(n){\n    　　　　return function(){\n                alert(n);  \n            }\n     　}(i)\n    }\n  \n方法五(jq)\n$(\"ul li\").click(function(){\n        var item = $(this).index();  //获取索引下标 也从0开始\n        alert(item);\n    })\n  \n方法六(事件代理)\n var ul = document.querySelector(\"ul\");\n    ulItem.onclick = function (e) {\n        e = e || window.event; //这一行及下一行是为兼容IE8及以下版本\n        var target = e.target || e.srcElement;\n        if (target.tagName.toLowerCase() === \"li\") {\n            var li = this.querySelectorAll(\"li\");\n            index = Array.prototype.indexOf.call(li, target);\n            alert(index);\n        }\n    }\n  \n方法七(jq事件代理)\n  $(document).ready(function () {\n        $(\"ul\").on(\"click\", function (event) {\n            var target = $(event.target);\n            alert(target.index())\n        });\n    });"}]