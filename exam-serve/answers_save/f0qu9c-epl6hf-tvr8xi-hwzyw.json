[{"title":"创建一副扑克牌","questions_id":"4vu7t9-t9vv08-chvz3r-n8i3nq","json_path":"4vu7t9-t9vv08-chvz3r-n8i3nq.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。\n\n52张正牌又均分为13张一组，并以黑桃、红桃、梅花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。\n\n要求：根据以下数据生成一副扑克牌（数组）。\n\n    var types = [\"红桃\", \"黑桃\", \"方块\", \"梅花\"]; // 花色\n    var points = [\"A\", 2, 3, 4, 5, 6, 7, 8, 9, 10, \"J\", \"Q\", \"K\"]; // 点数\n    var cards = [\"大王\", \"小王\"]; // 所有扑克牌","student_answer":"var types = [\"红桃\", \"黑桃\", \"方块\", \"梅花\"]; // 花色\nvar points = [\"A\", 2, 3, 4, 5, 6, 7, 8, 9, 10, \"J\", \"Q\", \"K\"]; // 点数\nvar cards = [\"大王\", \"小王\"]; // 所有扑克牌\nfor(let i = 0 ;i<points.length;i++){\n  for(let j = 0;j<types.length;j++){\n    cards.push({\n      points: points[i],\n      types: types[j]\n    })\n  }"},{"title":"性能优化","questions_id":"00a1t8-ezqkxg-xv9pkk-6hqfyb","json_path":"00a1t8-ezqkxg-xv9pkk-6hqfyb.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"请用js实现一个监听浏览器窗口变化的函数，当浏览器窗口的宽度大于等于 600px 的时候console.log('hello')（持续大于等于600px的话打印一次即可），请用你觉得最优的实现","student_answer":"let str =  '';\n\twindow.onresize = function(){  //onresize 事件会在窗口或框架被调整大小时发生\n\t\t\tif(document.body.clientWidth>= 600){\n\t\t\t\t\tif(str === ''){\n\t\t\t\t\t\tstr='hello';\n\t\t\t\t\t\tconsole.log(str);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t}"},{"title":"二叉树路径总和","questions_id":"41lnu-hbmz3-n6v989-hhfvtu","json_path":"41lnu-hbmz3-n6v989-hhfvtu.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"heinan","user_id":"fdjfr-msxp8a","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例一：\n给定如下二叉树，以及目标和 sum = 22\n```md\n             5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n```\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。","student_answer":"class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if(!root)\n            return false;\n        else if(!root->left&&!root->right)\n            return sum == root->val;\n        else if(root->left&&!root->right)\n        {\n            sum -= root->val;\n            return hasPathSum(root->left,sum);\n        }\n        else if(!root->left&&root->right)\n        {\n            sum -= root->val;\n            return hasPathSum(root->right,sum);\n        }\n        else\n        {\n            sum -= root->val;\n            return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);\n        }\n    }\n}"},{"title":"最高产的猪","questions_id":"oynzjn-gvvv5s-uowecl-m4yg2h","json_path":"oynzjn-gvvv5s-uowecl-m4yg2h.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"我们用一个 HTML 结构来表示一头猪的子子孙孙：\n<div class=\"pig\">\n  <div class=\"pig\">\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n    </div>\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n    </div>\n  </div>\n  <div class=\"pig\">\n    <div class=\"pig\"></div>\n    <div class=\"pig\"></div>\n  </div>\n  <div class=\"pig\">\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n    </div>\n  </div>\n</div>\n\n每个 DOM 节点都是一头猪，子节点就是这头猪的孩子。\n请你完成一个函数 mostProductivePigCount 它接受一个 DOM 节点作为参数，返回一个数组。存放同代猪的孩子的数量。\n\n比如第一代猪的孩子有3个，第二代猪的孩子分别有[2, 2, 1]，第三代猪的孩子分别有[1,1,0,0,5]","student_answer":"HTML\n<div class=\"pig\">\n  <div class=\"pig\">\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n    </div>\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n    </div>\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n    </div>\n  </div>\n  <div class=\"pig\">\n    <div class=\"pig\"></div>\n    <div class=\"pig\"></div>\n  </div>\n  <div class=\"pig\">\n    <div class=\"pig\">\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n      <div class=\"pig\"></div>\n    </div>\n  </div>\n</div>\n运用到广度优先搜索是属于图的算法中的一种，相对应的就是深度优先搜索。这里先只学习广度优先搜索。\n\n广度优先搜索就是按照数据结构的层次，一层层遍历搜索。它的思路是：\n\n将根节点放入队列中\n对当前队列进行遍历，对每一个成员进行处理（题目中就是求出成员的子节点数目）\n在对成员处理时，如果有子节点，则将所有未经过处理的子节点加入新的队列中\n当前队列遍历完成后，检查新的队列，如果新的队列中没有待检查的成员，则结束遍历\n如果新的队列中有待检查的成员，则重复步骤2\n\nconst findMostProductivePigChildrenCount = (dom) => {\n  let result = [];\n  // 广度优先遍历\n  const find = (targets, result) => {\n    // 下一轮待遍历的节点\n    let childrenTargets = [];\n    // 当前轮遍历后子节点的最大值\n    let max = 0;\n    // 当前轮遍历\n    for (let target of targets) {\n      // 如果有子节点\n      if (target.childElementCount) {\n        // 将子节点放入待遍历的数组中\n        childrenTargets.push(...target.children);\n        // 当前轮遍历后子节点的最大值\n        max = Math.max(max, target.childElementCount)\n      }\n    }\n    result.push(max);\n    // 进行下一轮遍历\n    if (childrenTargets.length) {\n      find(childrenTargets, result)\n    }\n  };\n  // 初始化遍历，根节点放入队列中\n  find([dom], result);\n  return result;\n}\n判断DOM子节点长度的时候用到了childElementCount属性，实际上也可以使用children.length代替的，没什么区别"}]