[{"title":"匿名自执行函数的应用","questions_id":"vh80e-3d3g3o-6hy47e-ib2x4c","json_path":"vh80e-3d3g3o-6hy47e-ib2x4c.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"heinan","user_id":"fdjfr-msxp8a","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"代码如下：\n```js\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function () {\n        console.log(i)\n    })\n}\n输出\n5\n5\n5\n5\n5\n```\n修改上面代码，打印结果要求为：0,1，2，3，4","student_answer":"for (var i = 0; i < 5; i++) {\n    setTimeout(function () {\n        console.log(i)\n    })\n}\n//输出  55555\nsetTimeout是异步执行的 循环一次 i为5   每次for循环都会输出为5循环5次有5次输出\nfor (let i = 0; i < 5; i++) {\n    setTimeout(function () {\n        console.log(i)\n    })\n}\n//输出01234\nlet i 的是区块变量，每个i只能存活到大括号结束，并不会把后面的for循环的i值赋给前面的setTimeout中的i,而var则是局部变量，这个i的生命周期不受for循环的大括号限制"},{"title":"react生命周期","questions_id":"xt05yo-prna5g-f7zqo-ltl5rh","json_path":"xt05yo-prna5g-f7zqo-ltl5rh.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"8sc5d7-7p5f9e-cb2zii-ahe5i","exam_name":"周考1","user_name":"dingshaoshan","user_id":"ypay2t-7uxsd","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"# react常用生命周期图\n\n## 请在 “其他“ 中查看图片。 \n \n\n\n如图是react常用生命周期图，请阅读图，并在1，2，3，4处填写对应的生命周期","student_answer":"1 shouldComponentUpdate\ncomponentDidMount \ncomponentDidUpdate"},{"title":"多种组件创建方式及其区别？","questions_id":"cbssqf-16avt7-qwk8k-ufilrc","json_path":"cbssqf-16avt7-qwk8k-ufilrc.json","subject_text":"渐进式开发(react)","subject_id":"fyu3ln-azjkie","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 多种组件创建方式及其区别？","student_answer":"函数式定义的无状态组件\nes5原生方式React.createClass定义的组件\nes6形式的extends React.Component定义的组件\n创建无状态函数式组件形式：\n在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode)\n组件不会被实例化，整体渲染性能得到提升\n因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。\n组件不能访问this对象\n无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件\n组件无法访问生命周期的方法\n因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。\n无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用\n\nReact.createClass`是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\nReact.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。\nReact.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components--HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。\n\n\nReact.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n函数this自绑定\nReact.createClass创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\nReact.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n当然，React.Component有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用method.bind(this)来完成绑定，还可以使用arrow function来绑定。\n  constructor(props) {\n       super(props);\n       this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n    <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n组件属性类型propTypes及其默认props属性defaultProps配置不同\nReact.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\nReact.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n组件初始状态state的配置不同\nReact.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；\nReact.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\nMixins的支持不同\nMixins(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用。\nReact.createClass在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n"},{"title":"分别使用DOM0级DOM2级给一个DIV绑定事件","questions_id":"1gsxn-k09c2j-gq8peo-sohe9","json_path":"1gsxn-k09c2j-gq8peo-sohe9.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"renyuliang","user_id":"bsz88g-071r5","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"分别使用DOM0级DOM2级给一个button绑定事件，并且描述这两种方式的区别","student_answer":"dom0级事件：\n绑定事件element.onclick=function(){}\n<!DOCTYPE html><html lang=\"en\"><head>\n  <meta charset=\"UTF-8\">\t\n    <title>Document</title></head><body>\t\n      <div id=\"app\">点击</div>\n<script type=\"text/javascript\">\nvar app=document.getElementById('app');\napp.onclick=function(){\t\n  alert(1);\t}\t\napp.onclick=function(){\t\t\n  alert(2);\t\n}\n</script>\n</body>\n</html>\n移除事件element.onclick=null;\n绑定事件element.addEventListener('事件类型',‘事件处理函数',true/false);\n第三个参数：true表示捕获，false表示冒泡，不填时默认为false\n<!DOCTYPE html>\n <html lang=\"en\"><head>\t<meta charset=\"UTF-8\">\t\n <title>Document</title></head><body>\n <div id=\"app\">点击</div>\n<script type=\"text/javascript\">\t\n var app=document.getElementById('app');\t\napp.addEventListener('click', fun1);\napp.addEventListener('click',fun2);\napp.addEventListener('mouseout',fun3);\nfunction fun1(){\n  alert(1);\t}\nfunction fun2(){\n  alert(2);\t}\nfunction fun3(){\n  alert(3);\t}\n</script>\n</body>\n</html>\n移除事件element.removeEventListener(('事件类型',‘事件处理函数',true/false);\n                         \n"},{"title":"最少两种方式实现点击每个li都弹出下标","questions_id":"puaqas-1modca-2y04jh-brcz59g","json_path":"puaqas-1modca-2y04jh-brcz59g.json","subject_text":"javaScript上","subject_id":"fqtktr-1lq5u","exam_id":"ukmp9b-radddj-ogwdr-nw3ane","exam_name":"周考3","user_name":"renyuliang","user_id":"bsz88g-071r5","questions_type_text":"手写代码","questions_type_id":"v8i73-r8oai","questions_stem":"<ul id=”test”>\n    <li>这是第一条</li>\n    <li>这是第二条</li>\n    <li>这是第三条</li>\n</ul>","student_answer":"使用利用事件冒泡委托给列表的父节点去处理的方式\nvar ulObj = document.getElementById(\"myUl\"); \nulObj.onclick = function (event) { \nvar tg = event.target; \nvar liArray = ulObj.getElementsByTagName(\"li\"); \nfor (var i = 0; i < liArray.length; i++) { \nif (liArray[i] === tg) { \nalert(i + 1); \n} \n} \n}\n使用闭包\nvar liArray = document.getElementById(\"myUl\").getElementsByTagName(\"li\"); \nfor (var i = 0; i < liArray.length; i++) { \n(function () { \nvar n = i; \nliArray[i].onclick = function () { \nalert(n + 1); \n} \n})(i) \n}\n"}]