[{"title":"vue基础知识","questions_id":"00o5nwy-qw7jj-ko6qkb-4uwrhv","json_path":"00o5nwy-qw7jj-ko6qkb-4uwrhv.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 谈谈Vue中v-for指令里key的作用？","student_answer":"当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (表单输入值) 的列表渲染输出，\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id"},{"title":"Vue基础知识","questions_id":"05snch-6eq8dn-szfd6q-t34nld","json_path":"05snch-6eq8dn-szfd6q-t34nld.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"简答题","questions_type_id":"774318-730z8m","questions_stem":"## 控制元素显示隐藏的指令v-if与v-show之间的区别及适用场景？","student_answer":"v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加css--display:none，dom元素还在；\n手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；\n编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。\nv-if和v-show都是用来控制元素的渲染。v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n"},{"title":"vue自定义指令","questions_id":"6ivrh-g7kp8a-2gixkg-p117t","json_path":"6ivrh-g7kp8a-2gixkg-p117t.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码阅读题","questions_type_id":"br9d6s-wh46i","questions_stem":"## 阅读如下代码，写出代码的功能，输入和输出\n```js\nVue.filter('formatDate', function(value){\n  let date = new Date();\n  date.setTime(value);\n  let year = date.getFullYear(),\n      month = (date.getMonth() + 1).toString().padStart(2, '0'),\n      day = date.getDate().toString().padStart(2, '0'),\n      hour = date.getHours().toString().padStart(2, '0'),\n      min = date.getMinutes().toString().padStart(2, '0'),\n      sec = date.getSeconds().toString().padStart(2, '0');\n  return `${year}-${month}-${day} ${hour}:${min}:${sec}`\n});\n```","student_answer":"调用一个函数方法，传递两个参数，第一个为字符串，第二个是一个回调函数，\n在函数里传入一个时间搓，在回调函数转义为2018-15-16-85格式的时间返回出去"},{"title":"使用async函数实现多张图片的依次加载（第一张加载完之后才能加载第二张）","questions_id":"fl7dll-xh6eo-hpri8a-edulg","json_path":"fl7dll-xh6eo-hpri8a-edulg.json","subject_text":"组件化开发(vue)","subject_id":"1psw2b-cy7o07","exam_id":"jpg8y9-zbzt7o-jpvuhf-fwnjvr","exam_name":"周考2","user_name":"chenmanjie","user_id":"w6l6n-cbvl6s","questions_type_text":"代码补全","questions_type_id":"fwf0t-wla1q","questions_stem":"## 使用async函数实现多张图片的依次加载（第一张加载完之后才能加载第二张）\n\n```js\n// 封装加载图片的promise  \nlet loadImg = (src)=>{\n    return new Promise((resolve, reject)=>{\n        // write your code here\n    })\n}   \nconst imgs = ['url1', 'url2', 'url3'];\n// 依次加载图片\nasync function fSync(imgs){\n   // write your code here\n}\n\nfSync(imgs);\n```","student_answer":"let loadImg = (src)=>{\n    return new Promise((resolve, reject)=>{\n       \t\tvar img = new Image();    \n\t\t\timg.src = src;    \n\t\t\tsetTimeout(()=>{\n\t\t\t\tresolve()\n\t\t\t},1000)\n\t\t\t   \n   \t })\n\t}\t   \n\tconst imgs = ['url1', 'url2', 'url3'];\n\t// 依次加载图片\n\n\tasync function fSync(imgs){\n   \tfor(let i=0;i<imgs.length;i++){\n   \t\t\tawait loadImg(imgs)\n\t\t}\n   \t}\n   \tfSync(imgs)"}]